* DART is a concolic testing tool  
* It applies to unit testing phase  
* DART does symbolic and concrete execution  
* DART can explore all paths when feasible  
* DART can automate unit testing  
&nbsp;
* DART automatically extracts the interface of a program using static source code parsing  
* DART generates a test driver which can give random inputs to the program  
* As the program executes, DART collects some information and generates new inputs through dynamic analysis  &nbsp;
&nbsp;
* DART elmiinated the need to write a test driver as it does it automatically  
* DART can detect standard errors  
* Sometimes through random testing it is unlikely to satisfy the conditions for an error to be produced  
* Dart can do inter procedural dynamic tracing: ex: `if f(x)==5 where function f returns 2*x, DART will replace f(x) by 2*x ` 
* DART does directed search by starting with the random input, checks the PC, and if some predicate was made true, it will now be made false and values are generated by the costraint solver  
* DART stops on identifying an error  
* Symbolic representation of a variable is its memory address  
* Memory M is a mapping from address locations m to words which are the actual contents  
* M'=M + `[ m |-> v]` Memory M is updated and only value of address m changes to value for v  
* Symbolic variables are identified by addresses  
* m can denote the meory address or the variable identified by address m  
* symbolic expression is a logical expression with symbolic variables and constants  
* Semantics of programs must be defined at memory level  
* Statements are machine instructions at the level of memory  
* Statement labels are denoted by instruction addresses  
* a function at(l,M) gives address of next instruction  
* evaluate-concrete(e,M) evaluates expression e using values in memory M and gives a value for e  
* Inputs to dart are memory locations corresponding to symbolic variables  
* input vector assigns an input value to each parameter and defines the initial value of memory M  
* A - assignment statements, C - Conditional statements  
* program execution w is Execs=(AUC)*(abort|halt)  
* Execs can be a tree with assignmentss having one successor and conditions with 2, leaves are abort or halt  
* symbolic memory S maps memory addresses to expressions  
* Whenever a path constraint is not linear, algo uses concrete values and not symbolic  
* case m: just a variable so directly return symbolic expression which is S(m) if m is in S and M(m) otherwise  
* case  `*(e',e")`: arithmetic operation with operance e' and e" so each should seperately be evaluated first. if either of the 2 evaluated expressions is not a constant then non linear expression is obtained so ust do concrete evaluation. If both are constants then do concrete evaluation. Otherwise if 1 is a constant, evaluate that expression and return  
* case `*e'` : pointer so first evaluate e', and then see if a constant is obtained. if it is a constant and is in the domain S, then `S*C `, otherwise M(`*c`). if it is not a constant them evaluate concrete  
* all_locs_definite: knows locations of all variables  
* substituting concrete values overcomes unsolvability of pc by constraint solver sometimes  
  
* DART test driver  
* iitialize all boolean to true  
* Repeat loop while all linear and all locations are defined  
* DART keeps a stack , input vector and boolean var directed which is for directed search  
* instrument program is a function called in the test driver with stack and input vector  
* DART can run forever  
* instrumented program initializes inputs with random values in input vector if not initialized  
* it initializes memory and sets uo symbolic memory, sets initial program counter  
* if a new assignment statement is encountered, is is symbolically and concretely evaluated and memory location is updated  
* for conditional statement, concrete evaluation done and checks if it shoulf take then or else branch and updates path constraint and stack accordingly  
* stack keeps track of path constraint that was last added  
* the PC at the Ifp if the stack is what dart will flip  
* If halt is encountered, must solve path constraint, calls a constraint solver  
* in the instrumented prorgam, branch value is recorded and is 1 for then. done value is noted and is 0 when path has already been explored  
* stack has infro related to each conditional statement.  
* if DART prints bug found, then input that causes abort. If terminates without printing then no input that causes abort. otherwise it runs forever

