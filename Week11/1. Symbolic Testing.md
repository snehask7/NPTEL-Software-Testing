# Symbolic Testing  
* Program proving: Any input is given and programs execute correctly. Involve formal methods  
* Program testing: only a set of testcases are used  
* Formal methods are mathematical techniques based on deriving formal models from program. Formmal models include model checking, theorem proving, program analysis   
* Program is not even executed in program proving and program is proved to meet specification  
* Not all proofs can be automated  
* Symbolic execution is in between proving and testing. It executes a program symbolically for a set of inputs  
* Each symbolic execution is equal to a large number of normal test cases  
* Symbolic values ex: alpha1 is a placeholder for a concrete value (can be thought of as a variable)  
* PC - path constraint : conditions that collect predicates related to RIPR (marked as true if it is reachable)  
* Symbolic execution tree: Has conditional statements and test case which make the condition true and false  
* Variables are in terms of symbolic values as symbolic expressions  
* Symbolic state (sigma): symbolic expressions for each variable at a point of time  
* Symbolic path constraint: predicate formula to reach a statement  
* Symbolic execution generates test input for each execution path of a program  
* Execution path is a sequence of true and false where true/false at the ith position in the sequence denotes that the ith conditional statement in the path took the then(for true) and else (for false)  
* symbolic state sigma is initially empty  
* At a read statement (for example parameter passing to the function) symbolic values are assigned to each variable and the mapping is added to sigma  
* At an assignment statement v=e, symbolic expressions are assigned. Sigma is updated by mapping variable v to sigma(e)
* PC is initialized to true at the beginning of symbolic execution  
* At a conditional statement if(E) then .. else .., PC is PC ^ sigma(e) for then branch and PC ^ !sigma(e) for the else branch  
* Each path constraint (predicate formula) is solved to find a suitable assignment of concrete to symbolic values and if it is satisfiable then symbolic exec continues. Otherwise, it terminates  
* At the end of symbolic execution, PC is solved using constraint solver. If concrete values are obtained then those are test inputs  
* When the concrete obtained are used to test, all execution paths are tested  

